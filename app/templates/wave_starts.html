{% extends "base.html" %}
{% block content %}
<h1>Automated Wave Starts</h1>
<div class="card">
  <form id="wave-form" method="post" action="/race/{{ race.race_id }}/part/{{ race_part_id }}/submit-start/wave/data">
    <label>
      Participants and/or Groups (comma-separated)
      <input type="text" name="targets" required />
    </label>
    <div class="actions">
      <button id="start-wave" type="submit">Start Wave Starts</button>
      <button class="ghost" id="cancel-wave" type="button" disabled style="display: none;">Cancel</button>
    </div>
  </form>
</div>
<div class="card">
  <div id="wave-status" class="small">Waiting to startâ€¦</div>
  <div class="table-wrap">
    <table class="table" id="wave-table">
      <thead>
        <tr>
          <th>Bib</th>
          <th>Group</th>
          <th>Offset</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
  const form = document.getElementById('wave-form');
  const tbody = document.querySelector('#wave-table tbody');
  const status = document.getElementById('wave-status');
  const startButton = document.getElementById('start-wave');
  const cancelButton = document.getElementById('cancel-wave');
  let waveRunning = false;
  const scheduled = new Map();
  let remainingStarts = 0;
  let cancelMode = 'cancel';

  function renderSchedule(schedule) {
    tbody.innerHTML = '';
    schedule.forEach(item => {
      const row = document.createElement('tr');
      row.dataset.participantId = item.participant_id;
      row.innerHTML = `
        <td>${item.participant_id}</td>
        <td>${item.group}</td>
        <td>${Math.floor(item.offset_seconds / 60)}:${String(item.offset_seconds % 60).padStart(2, '0')}</td>
        <td class="small">waiting</td>
      `;
      tbody.appendChild(row);
    });
  }

  function markGo(row) {
    row.querySelector('td:last-child').textContent = 'GO';
    row.style.background = '#fff0d2';
  }

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    if (waveRunning) {
      status.textContent = 'Wave already running. Cancel to start a new one.';
      return;
    }
    const response = await fetch(form.action, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams(new FormData(form)),
    });
    const data = await response.json();
    const schedule = data.schedule || [];
    renderSchedule(schedule);
    if (!schedule.length) {
      status.textContent = 'No valid participants for wave start.';
      return;
    }
    status.textContent = 'Wave started.';
    waveRunning = true;
    remainingStarts = schedule.length;
    cancelMode = 'cancel';
    startButton.disabled = true;
    startButton.style.display = 'none';
    cancelButton.disabled = false;
    cancelButton.style.display = 'inline-flex';
    cancelButton.textContent = 'Cancel';
    schedule.forEach(item => {
      const delay = item.offset_seconds * 1000;
      const timeoutId = setTimeout(async () => {
        const row = tbody.querySelector(`tr[data-participant-id="${item.participant_id}"]`);
        if (row) {
          markGo(row);
        }
        await fetch(`/race/{{ race.race_id }}/part/{{ race_part_id }}/submit-start/api`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ participant_id: item.participant_id }),
        });
        beep();
        remainingStarts -= 1;
        if (remainingStarts <= 0) {
          waveRunning = false;
          cancelMode = 'clear';
          status.textContent = 'Wave completed.';
          cancelButton.textContent = 'Clear';
        }
      }, delay);
      scheduled.set(item.participant_id, timeoutId);
    });
  });

  cancelButton.addEventListener('click', () => {
    if (cancelMode === 'clear') {
      window.location.reload();
      return;
    }
    if (!waveRunning) {
      return;
    }
    for (const timeoutId of scheduled.values()) {
      clearTimeout(timeoutId);
    }
    scheduled.clear();
    waveRunning = false;
    remainingStarts = 0;
    startButton.disabled = false;
    startButton.style.display = 'inline-flex';
    cancelButton.disabled = true;
    cancelButton.style.display = 'none';
    status.textContent = 'Wave cancelled.';
  });
</script>
{% endblock %}
