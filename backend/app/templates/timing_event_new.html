{% extends "base.html" %}
{% block content %}
<div class="mb-3">
  <div class="text-muted"><a href="/races/{{ race.race_id }}/parts/{{ part.race_part_id }}">← Back</a></div>
  <h1 class="h3 m-0">Submit timing event</h1>
  <div class="text-muted">{{ race.race_id }} • {{ part.name }} • Type: {{ part.time_event_type }}</div>
</div>

<div class="row g-3">
  <div class="col-12 col-lg-6">
    <div class="card shadow-sm">
      <div class="card-body">
        <form method="post" id="timing-form">
          <div class="mb-3">
            <label class="form-label">Bib number</label>
            <input class="form-control form-control-lg" name="participant_id" id="participant_id" inputmode="numeric" autofocus required>
            <div class="form-text">Tip: on phones, scan QR below to fill this automatically.</div>
          </div>

          {% if part.time_event_type == "duration" %}
            <div class="mb-3">
              <label class="form-label">Duration</label>
              <input class="form-control form-control-lg" name="duration" id="duration" placeholder="MM:SS or HH:MM:SS or seconds" required>
            </div>
          {% else %}
            <input type="hidden" name="duration" value="">
          {% endif %}

          <input type="hidden" name="client_timestamp_ms" id="client_timestamp_ms" value="">

          <button class="btn btn-primary btn-lg w-100" type="submit">
            {% if part.time_event_type == "end_time" %}Submit finish{% else %}Submit duration{% endif %}
          </button>

          <div class="small text-muted mt-2">
            For end-time mode, the server stores the submit time as finish time.
            If two organizers scan the same bib, the earliest finish counts in results.
          </div>
        </form>
      </div>
    </div>
  </div>

  {% if part.time_event_type == "end_time" %}
  <div class="col-12 col-lg-6">
    <div class="card shadow-sm">
      <div class="card-body">
        <h2 class="h5">QR scanner (optional)</h2>
        <p class="text-muted small">Allow camera access, then scan the bib QR. It will auto-submit and stay ready for the next scan.</p>

        <div id="qr-reader" style="width: 100%;"></div>
        <div class="mt-2 d-flex gap-2 flex-wrap">
          <button class="btn btn-outline-primary btn-sm" id="start-scan" type="button">Start scanning</button>
          <button class="btn btn-outline-secondary btn-sm" id="stop-scan" type="button" disabled>Stop</button>
        </div>
        <div id="scan-status" class="mt-3 small"></div>
      </div>
    </div>
  </div>
  {% endif %}
</div>
{% endblock %}

\
{% block scripts %}
<script>
  // Always store client-side timestamp as a backup (server time is the source of truth)
  document.getElementById("client_timestamp_ms").value = Date.now();

  {% if part.time_event_type == "end_time" %}
  let qr;
  let lastBib = null;
  let lastScanAt = 0;

  const statusEl = document.getElementById("scan-status");
function beepSuccess() {
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) return;
    const ctx = new AudioCtx();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "sine";
    o.frequency.value = 880; // A5-ish
    g.gain.value = 0.05;
    o.connect(g);
    g.connect(ctx.destination);
    o.start();
    setTimeout(() => { o.stop(); ctx.close(); }, 120);
  } catch (e) { /* ignore */ }
}

function vibrateSuccess() {
  try {
    if (navigator.vibrate) navigator.vibrate([60, 30, 60]);
  } catch (e) { /* ignore */ }
}

function setStatus(msg, kind) {
    if (!statusEl) return;
    const cls = kind === "ok" ? "text-success" : (kind === "warn" ? "text-warning" : "text-danger");
    statusEl.className = "mt-3 small " + cls;
    statusEl.textContent = msg;
  }

  async function submitBibBackground(bib) {
    const url = window.location.pathname;
    const fd = new FormData();
    fd.set("participant_id", bib);
    fd.set("duration", "");
    fd.set("client_timestamp_ms", String(Date.now()));

    const res = await fetch(url, {
      method: "POST",
      body: fd,
      headers: { "X-Requested-With": "fetch" },
      redirect: "manual",
      cache: "no-store",
      credentials: "same-origin",
    });

    if (!res.ok) {
      const t = await res.text();
      throw new Error(t || ("HTTP " + res.status));
    }
    return true;
  }

  function onScanSuccess(decodedText, decodedResult) {
    const m = decodedText.match(/\d+/);
    if (!m) return;
    const bib = m[0];

    const now = Date.now();
    if (bib === lastBib && (now - lastScanAt) < 2000) return;
    lastBib = bib;
    lastScanAt = now;

    setStatus(`Submitting bib ${bib}…`, "warn");

    submitBibBackground(bib).then(() => {
      setStatus(`✅ Submitted bib ${bib}`, "ok");
      beepSuccess();
      vibrateSuccess();
    }).catch((e) => {
      console.warn(e);
      setStatus(`❌ Failed to submit bib ${bib}: ${e.message}`, "err");
    });
  }

  async function startScan() {
    if (!window.Html5Qrcode) {
      alert("html5-qrcode did not load. Are you offline, behind a blocker, or is cdnjs blocked?");
      return;
    }
    qr = new Html5Qrcode("qr-reader");
    const config = { fps: 10, qrbox: { width: 250, height: 250 } };
    await qr.start({ facingMode: "environment" }, config, onScanSuccess);
    document.getElementById("start-scan").disabled = true;
    document.getElementById("stop-scan").disabled = false;
    setStatus("Camera started. Scan bib QR codes.", "ok");
  }

  async function stopScan() {
    if (!qr) return;
    await qr.stop();
    await qr.clear();
    qr = null;
    document.getElementById("start-scan").disabled = false;
    document.getElementById("stop-scan").disabled = true;
    setStatus("Camera stopped.", "warn");
  }

  document.getElementById("start-scan").addEventListener("click", startScan);
  document.getElementById("stop-scan").addEventListener("click", stopScan);
  {% endif %}
</script>
{% endblock %}

